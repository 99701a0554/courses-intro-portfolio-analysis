---
title       : Performance drivers
description : In addition to studying portfolio performance based on the observed portfolio return series, it is relevant to reverse engineer those performance measures and find out how individual (expected) returns, volatilities and correlations interact to determine the total portfolio performance. 

--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:27fc122215
## The sources of portfolio performance

Chapter 2 introduced you to the *univariate* approach of analyzing portfolio performance based on a statistical analysis of the portfolio return series. In this chapter, you will consider a *multivariate* approach. You will study how the portfolio performance is affected by the interaction between the performance of individual portfolio positions.

For a first example you will look at a portfolio invested in two very different *echange traded funds* (ETFs). The first is an ETF tracking the broad US equities market (ETF with the symbol SPY), and a second ETF that tracks the US bonds market (EFT with the symbol AGG). You have a portfolio that is invested 60/40, meaning that every month you invest 60% in the equities ETF (SPY), and 40% in the bonds ETF (AGG).

These returns are in your workspace as `returns_bonds`, `returns_equities`, and `returns_6040`. Explore these returns in your console and verify which of the following statements are false.

*** =instructions

- A portfolio is less volatile than the sum of its component volatilities. This implies that the standard deviation of the 60/40 portfolio is less than `0.6 *  sd(returns_equities) + 0.4 * sd(returns_bonds)`. We call this the subadditivity property of the standard deviation.    
- The portfolio mean return equals the sum of the component average returns, that is, `mean(returns_6040)==0.6*mean(returns_equities)+0.4*mean(returns_bonds)`.  
- None of the above statements are correct. 

*** =hint
hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

### plot
weights <- c(0.6,0.4)
prices <- cbind(eq_prices,bond_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_6040 <- Return.portfolio(returns, weights,rebalance_on="months")
# check: all.equal( as.numeric(returns_6040),as.numeric(0.6*returns[,1]+0.4*returns[,2])  )
prices_6040 <- zoo(cumprod(1+returns_6040),order.by=time(returns_6040))
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices) )
ylim <- c( min( temp ) , max(temp) )
plot.zoo(eq_prices , main="Equity-bond portfolios",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(prices_6040,col="blue")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)","60/40 Equities-Bonds") , col=c("black","red","blue") , lwd = 1 )

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sct
```{r}
test_mc(3) # if 3 is the correct option.
```

--- type:NormalExercise lang:r xp:50 skills:1     key:69c5664fdb
## Sensitivity of the Sharpe ratio to the porfolio weights

The choice of portfolio weights matters.  


*** =instructions
- Complete the R script that runs a grid search to determine the portfolio weights for which the Sharpe ratio is the highest, assuming a zero risk free rate.  

*** =hint
hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# returns_equities and returns_bonds are preloaded

# grid defining possible weights equities 
grid <- seq(0,1,0.01)
# initialize vector in which the Sharpe ratios will be stacked
vsharpe <- rep(NA,length(grid))
# initialize counter
i <- 1
#loop over the elements in the search grid
for(w in grid){
  # portfolio returns are monthly rebalanced
  preturns <- w*returns_equities+(1-w)*returns_bonds
  # compute the shapre ratio of preturns
  vsharpe[i] <- 
  # update counter  
  i <- 
}
# plot the obtained Sharpe ratios against the equity weights
plot(  ,   ,xlab="Equity weights",ylab="Ann. Sharpe ratio")
abline(v=grid[vsharpe==max(vsharpe)],lty=3)
```


*** =solution
```{r}
# PerformaneAnalytics is pre-loaded
# returns_equities and returns_bonds are preloaded
grid <- seq(0,1,0.01)
vsharpe <- rep(NA,length(grid))
i <- 1
for(w in grid){
  preturns <- w*returns_equities+(1-w)*returns_bonds
  vsharpe[i] <- SharpeRatio.annualized(preturns)
  #vsharpe[i] <- SharpeRatio.annualized(preturns)
  i <- i+1
}
plot(grid,vsharpe,xlab="weights",ylab="Ann. Sharpe ratio")
abline(v=grid[vsharpe==max(vsharpe)],lty=3)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1 key:bf1fc7dc803e342b4475c296bbebc2bab9b26f32
## The drivers in case of two assets

*** =video_link
//player.vimeo.com/video/108225030


--- type:NormalExercise lang:r xp:100 skills:1 key:b6a986b0e53bd119933fc39df94f21f2bf1e4318
## Interpreting correlation

Now you will learn how to compute the correlation between equity returns and bond returns. Just like volatilities, these correlations are dynamic. Therefore you need to distinguish between a static analysis that calculates correlations over a complete samples, and a dynamic analysis that calculates correlations over a rolling sample. 

In this exercise you will learn 3 new functions from the PerformanceAnalytics package. These are `chart.Scatter`, `chart.Correlation`, and `chart.RollingCorrelation`. 

*** =instructions
- Plot the equity returns `returns_equities` against the bond returns `returns_bonds` using the function `chart.Scatter`. Do you see a relation? 
- Compute first the correlation between the variables `returns_equities` and `returns_bonds` using the standard function `cor()`. 
- Merge `returns_equities`, and `returns_bonds`, call this `returns`. 
- Compute and visualize the correlation again except using `chart.Correlation` with `returns` as the argument.
- Commpute the rolling 24-month estimates of the bond-equity correlation using the function `chart.RollingCorrelation`, use the arguments `"R"`, and `"width"`. 

*** =hint
`chart.RollingCorrelation` uses two time-series for the argument `"R"`, and the `"width"` is the number of months. 

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# load package
library(PerformanceAnalytics)
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# Create a scatter plot


# Find the correlation


# Merge returns_equities and returns_bonds 


# Find and visualize the correlation using chart.Correlation


# Visualize the rolling estimates using chart.RollingCorrelation

```

*** =solution
```{r}
# Create a scatter plot
chart.Scatter(returns_equities,  returns_bonds)

# Find the correlation
cor(returns_equities,  returns_bonds)

# Merge returns_equities and returns_bonds 
returns <- merge(returns_equities,returns_bonds)

# Find and visualize the correlation using chart.Correlation
chart.Correlation(returns)

# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(returns_equities, returns_bonds, width = 24)

```

*** =sct
```{r}
# sct code
#1st
test_function("chart.Scatter", c("x", "y"))

#2nd
test_function("cor", c("x", "y"))

#3rd
test_object("returns")

#4th
test_function("chart.Correlation", c("R"))

#5th
test_function("chart.RollingCorrelation", c("Ra", "Rb", "width"))
success_msg("Well done!")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1     key:f4f41f6b81
## The impact of correlation on performance.


We thus observed that  like the mean and volatility, the correlation is changing over time. This time-variation can have major effects on the portfolio volatility. In your workspace, a sensitivity plot is shown for the 60/40 and the 40/60 portfolio invested in equities and bonds over the sample. In the plot, the annualized standard deviation and volatilities are kept fixed at their sample estimates, while the correlation varies between -1 and 1. 

Consider an equally weighted portfolio of two assets with 10% and 20% volatility, respectively. Their correlation jumps from 0 to 0.5. Then the portfolio variance:    

*** =instructions
- Decreases with 50%
- Almost doubles
- Does not change  

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# load package
library(PerformanceAnalytics)
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities

# standard deviations
sig1 <- sqrt(12)*sd(returns_equities)
sig2 <- sqrt(12)*sd(returns_bonds)
# corrleation grid
grid <- seq(-1,1,0.01)
# initializing solution vector
w <- 0.6
vpsd_6040 <- sqrt( w^2*sig1^2 + (1-w)^2*sig2^2 + 2*w*(1-w)*sig1*sig2*grid  )
w <- 0.4
vpsd_4060 = sqrt( w^2*sig1^2 + (1-w)^2*sig2^2 + 2*w*(1-w)*sig1*sig2*grid  )  
plot(grid,vpsd_6040,xlab="correlation",ylab="Ann. standard deviation",
      ylim = c(sig2,sig1),type="l")
lines(grid,vpsd_4060,col="red")
legend("topleft", legend=c("60/40 Equities-bonds","40/60 Equities-Bonds") , col=c("black","red") , lwd = 1 )


 # ((0.5^2*0.10^2+0.05^2*0.20^2+2*0.5*0.5*0.5)-(0.5^2*0.10^2+0.05^2*0.20^2))/(0.5^2*0.10^2+0.05^2*0.20^2)
```


*** =sct
```{r}
# sct code
test_mc(2) 
```

--- type:VideoExercise lang:r xp:50 skills:1 key:a2866e000af4e20577dc0d48d46765e2da1a7d9b
## The general case using matrix notation

*** =video_link
//player.vimeo.com/video/108225030

--- type:NormalExercise lang:r xp:100 skills:1   key:21e408b8c65335ed2599fcb8ff64b5c9b352c374
## The asset allocation problem

Investors know that each asset that they invest in has risk, and that each asset performs differently. Thats why you will not only invest in US equities and US bonds, bu you will *diversify* your portfolio by investing in real estate, commoditites, among others! 

In this example you have decided to extend your investment opportunity by creating a portfolio that consists of US equities ETF (SPY), US bonds ETF (AGG), a real estate investment trust (VEIEX), and an ETF tracking in the GSCI commodities index (GSG). The plot in the environment displays the performance of these investments.

The monthly returns on those investment are available as the variable `returns` in your workspace. 

*** =instructions
- Create a vector of the weights of a portfiol that is invested 40% in equities, 40% in bonds, 10% in real estate, and 10% in commodities. Call this new variable `weights`.
- Calculate the portfolio returns using `Return.portfolio`, and rebalance your weights monthly. Assign this to `preturns`.
- Merge `returns` and `preturns` and call this `returns_merged`.
- Use `table.AnnualizedReturns` to compare portfolio performance.

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])


### plot

prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices),as.numeric(re_prices), as.numeric(comm_prices)   )
ylim <- c( min( temp ) , 1.4*max(temp) )
plot.zoo(eq_prices , main="Performance across asset classes",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(re_prices,col="blue")
lines(comm_prices,col="purple")
legend("topleft", legend=c("Equities (SPY)","Bonds (AGG)", "Real estate (VEIEX)",
                           "Commodities (GSG)") , col=c("black","red","blue","purple") , lwd = 1 ,ncol=1)

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Create a vector of portfolio weights


# Calculate portfiolo weights


#Merge returns and portfolio returns


# Print a table of annualized returns
```

*** =solution
```{r}
# Create a vector of portfolio weights
weights <- c(0.4, 0.4, 0.1, 0.1)

# Calculate portfiolo weights
preturns <- Return.portfolio(returns, weights, rebalance_on = "months")

#Merge returns and portfolio returns
returns_merged <- merge(returns, preturns)

# Print a table of annualized returns
table.AnnualizedReturns(returns_merged)
```

*** =sct
```{r}
#1st
test_object("weights", incorrect_msg = "Did you calculate the weights correctly?", undefined_msg = "Be sure to calculate the weights!")

#2nd
test_object("preturns", incorrect_msg = "Did you provide both `returns` and `weights` to `Return.portfolio`?")
test_function("Return.portfolio", c("R", "weights", "rebalance_on"))

#3rd
test_object("returns_merged")

#4th
test_function("table.AnnualizedReturns", "R")
# sct code
success_msg("Well done!")
```




--- type:NormalExercise lang:r xp:100 skills:1 key:080c6863fc
## Avoiding loops in calculating vector of estimates 

We could Use colMeans to compute the expected return vector. Then sum(weights*mu).

*** =instructions
- Compute the vector of average returns on those four investments using the R command `apply(returns,2,"mean")` and call this `vmeans`.
- Do the same to compute the vector standard deviations and call this `vsd`.
- Use the following R instructions to produce the scatter plot of average returns with respect to standard deviations:
`plot(vsd,vmeans,col="gray",xlim=c(0,0.10))
text( vsd ,  vmu ,  labels=colnames(returns), cex= 0.7)`
- Add a dashed horizontal line at `h=0` using [abline](http://www.rdocumentation.org/packages/graphics/functions/abline) by setting the argument `lty=3`
*** =hint
hint comes here

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
# vector of means
 
# vector of standard deviations

# scatter plot
 


```


*** =solution
```{r}
# vector of means
vmeans <- apply(returns,2,"mean")
# vector of standard deviations
vsd <- apply(returns,2,"sd")
# scatter plot
plot(vsd,vmeans,col="gray",xlim=c(0,0.10))
text( vsd , vmeans,  labels=colnames(returns), cex= 0.7)
abline(h=0,lty=3)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:9786a14448b7689cc1be071bd4f4408ceadd0ee7
## Portfolio volatility

Use cov to compute the sample covariance matrix. use of %*% or StdDev in PerformanceAnalytics. to see.

*** =instructions
- instruction 1
- instruction 2

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1   key:ba9b12d382
## The portfolio's risk budget

*** =video_link
//player.vimeo.com/video/108225030

--- type:NormalExercise lang:r xp:100 skills:1 key:0931e83c3a402b2fb2d78958981928a327428e4d
## Whodunit

compute the portfolio risk budget... barplot? function [StdDev](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/StdDev)

*** =instructions
- Set `vol_budget <- StdDev(returns,portfolio_method="component",weights=c(0.4,0.4,0.1,0.1))` and print this variable;
- Combine the weights and the percentage risk contributions in a table called `weights_percrisk`;
- Make a barplot and note how different the percentage risk contributions are compared to the portfolio weights. 

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code

vol_budget <- StdDev(returns,portfolio_method="component",weights=c(0.4,0.4,0.1,0.1))
out <- cbind( c(0.4,0.4,0.1,0.1) ,  vol_budget$pct_contrib_StdDev)
colnames(out) <- c( "weights" , "perc risk contrib")
barplot(out)
 
  
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

