---
title       : Optimizing the portfolio 
description : We have up to now considered the portfolio weights as given. Here we consider optimizing the portfolio weights. Markowitz mean variance optimized portfolios.


--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:139d7eabbd827860709b29f2a8d968614d1e3cb0
## Comparing investments in portfolios of DJIA stocks 

In the workspace, you see a scatter plot showing the mean and standard deviation of the 30 Dow Jones Industrial Average stocks, as estimated on their monthly returns over the period 1991-2015. Each of the stocks is identified in the plot using
its ticker. 

Assume an investor who only cares about the mean and variance of the portfolio return distribution. She likes expected returns and dislikes variance.  Which of the following statements is false:

*** =instructions
- If a mean-variance investor has to invest all her wealth in one asset, then the opportunity of investing in Home Depot (ticker: HD) dominates an investment in Caterpillar (ticker: CAT) since it has a higher average return and lower risk.  
- A mean-variance investor will never combine investments in Home Depot and Caterpillar in her portfolio. 
- By combining investments, it may be possible to obtain a portfolio with a lower variance than the variance of the Exxon Mobil Corporation's stock (ticker: XOM). 
- If an investor is not allowed to borrow, then there is no portfolio invested in thirty Dow Jones Industrial Average stocks, offering a higher average return than the one of Apple (ticker: AAPL).   

*** =hint
hint

*** =pre_exercise_code
```{r}
# pec
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

stockmu = apply( X = returns , MARGIN = 2 , FUN="mean")
stocksd = apply( X = returns , MARGIN = 2 , FUN="sd")

# make the scatter plot and add tickers

plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly)",xlim=c(0,1.1*max(stocksd)),ylim=c(0,1*1*max(stockmu)))
text( stocksd ,  stockmu ,  labels=colnames(returns ), cex= 0.7)
text( stocksd[c("HD","CAT","XOM","AAPL")]  ,  stockmu[c("HD","CAT","XOM","AAPL")] ,  labels=  c("HD","CAT","XOM","AAPL") , cex= 0.9,col="red")
```

*** =sct
```{r}
test_mc(2) # if 2 is the correct option.
```

--- type:NormalExercise lang:r xp:100 skills:1   key:8c67f73515
## Exploring monthly returns of the 30 DJIA stocks 

The 1991-2015 monthly returns on the 30 DJIA stocks are available in the workspace as the variable `returns`.



*** =instructions
- Verify that `returns` is an object of the xts-class using the function `class`.
- Plot the row means of `returns` (in other words, the returns on the monthly rebalanced equally-weighted  portfolio returns). 
- Plot the histogram of the correlations between the monthly returns of the DJIA stocks. Because of the symmetry of the correlation matrix, you only need the lower triangular elements, which, for any square matrix `Z`, you can select using `Z[lower.tri(Z)]`.
*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# returns is pre-loaded
# class of returns

# plot ew portfolio returns

# histogram of correlations

```

*** =solution
```{r}
# returns is pre-loaded
# class of returns
class(returns)
# plot ew portfolio returns
plot.zoo(rowMeans(returns))
# histogram of correlations
Z <- cor(returns)
hist(Z[lower.tri(Z)])
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:2d45c303bc2e49767a9cd744f15a31938a2ec7d9
## Modern portfolio theory of Harry Markowitz


*** =video_link
//player.vimeo.com/video/108225030



--- type:NormalExercise lang:r xp:100 skills:1 key:c066b2d5f610d13afdb48831249d18142590def7
## Find the mean-variance efficient portfolio with target equal to EW  

A convenient function for finding mean-variance efficient portfolio weights in R is the function [portfolio.optim](http://www.rdocumentation.org/packages/tseries/functions/portfolio.optim) in the R package [tseries](http://www.rdocumentation.org/packages/tseries). Its default implementation finds the mean-variance efficient portfolio weights under the constraint that the portfolio return equals the return on the equally-weighted portfolio. 
The only argument needed is the monthly return data on the portfolio components for which the weights need to be determined.


*** =instructions
- load the library `tseries`. 
- define `out` as the output of applying the default version of `portfolio.optim` on `returns`.
- the optimized portfolio weights are in `out$pw`. Print them from largest to smallest, with rounding to 4 decimals.
- Visualize the weights larger than 1% through a barplot graph.
- Verify that the optimized portfolio returns in `out$px` dominate the returns of the equally weighted portfolio.

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# load tseries

# optimize
out <-  
# output
optim_weights <- out$pw
names(optim_weights) <- colnames(returns)
optim_returns <-  out$px 
# round sorted
round( sort(    ,decreasing=T) ,4)
# barplot
   (optim_weights[optim_weights>=0.01])
# equally weighted returns
ew_returns <- rowMeans(returns)
# strict lower standard deviation
 
# same or higher return
 
```

*** =solution
```{r}
# solution code
# load tseries. 
library(tseries)
# optimize
out <- portfolio.optim(returns)
# output
optim_weights <- out$pw
names(optim_weights) <- colnames(returns)
optim_returns <- xts(out$px,order.by=time(returns))
# round sorted
round(sort(optim_weights,decreasing=T) ,4)
# barplot
barplot(optim_weights[optim_weights>=0.01])
# dominate
ew_returns <- rowMeans(returns)
# strict lower standard deviation
sd(optim_returns); sd(ew_returns)
( sd(optim_returns ) < sd(ew_returns) )
# same or higher return
mean(optim_returns); mean(ew_returns)
mean(optim_returns) >= mean(ew_returns)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:6f3df5bc7125d675f226ddc4c69639e2cf24d23c
## Imposing weight constraints

Investors are often constrained in the maximum values allowed for the portfolio weights. Finding the optimized portfolio under a maximum weight is possible in the function [portfolio.optim](http://www.rdocumentation.org/packages/tseries/functions/portfolio.optim)  by setting the argument
 `reshigh` to the vector of maximum weights for each asset.  
 
 The advantage of a maximum weight constraint is that the portfolio will be less concentrated. Let's verify this statement when the target expected return is still equal to the equally-weighted return.

*** =instructions
- Modify the sample code to impose a maximum 10% constraint on each of the portfolio weights and compute the number of positions larger than 1%;
- Repeat the above with a maximum 5% constraint.

*** =hint
The argument `reshigh` needs to be a vector. 

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

library(tseries)
```

*** =sample_code
```{r}
# sample code
# tseries is pre-loaded
out <- portfolio.optim(returns,reshigh=rep(1,ncol(returns)))
sum( 1*(out$pw > 0.01))


```

*** =solution
```{r}
# solution code
out <- portfolio.optim(returns,reshigh=rep(1,ncol(returns)))
sum( 1*(out$pw > 0.01))

out <- portfolio.optim(returns,reshigh=rep(0.1,ncol(returns)))
sum( 1*(out$pw > 0.01))

out <- portfolio.optim(returns,reshigh=rep(0.05,ncol(returns)))
sum( 1*(out$pw > 0.01))
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1 key:461436d2ee4b426f97b3c95b6ee39836ae38b34f
## The efficient frontier

Concept of minimizing variance given a sequence of return targets starting from the lowest to highest expected returns
*** =video_link
//player.vimeo.com/video/108225030

--- type:NormalExercise lang:r xp:100 skills:1 key:2c03a87fc29fb66e35d8cdbf244b3dcf41305824
## Computing the efficient frontier 

As we have seen, we need to first define the grid of target returns. We will set the maximum target return to the maximum average return of the stocks. The minimum target return is the return of the minimum variance portfolio. We don't know this minimum variance portfolio return yet. Let's therefore take the largest possible grid starting with the minimum average returns of all stocks. 


*** =instructions
- Complete the code specifying the grid of 100 equally space return targets starting at the minimum and maximum average return 
- Run the loop computing the optimized weights and corresponding mean return and volatility
- Plot the portfolio mean against the portfolio volatility of the optimized portfolios
- Improve the efficient frontier plot by removing the inefficient portfolios offering a lower return at a higher risk compared to the minimum variance portfolio.  

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
# solution code
stockmu = colMeans(returns)
grid = seq( , ,length.out=100 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()
for( mutarget in grid ){
  out = try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm = c(vpm,out$pm)
    vpsd = c(vpsd,out$ps)
    mweights = rbind( mweights,out$pw)
  }
}
# report the scatter plot of vpm agains vpsd

```

*** =solution
```{r}
# solution code
stockmu = colMeans(returns)
grid = seq(min(stockmu),max(stockmu),length.out=100 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()

for( mutarget in grid ){
  out = try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm = c(vpm,out$pm)
    vpsd = c(vpsd,out$ps)
    mweights = rbind( mweights,out$pw)
  }
}
# report the scatter plot of vpm agains vpsd
plot(vpms,vpm)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1   key:897a83541a
## The minimum variance and maximum Sharpe ratio portfolio

In the console you see the previous plot to which the mean and volatilities of the stocks have been added. 



*** =instructions
- 
- Determine minimum variance portfolio and maximum Sharpe ratio portfolio (assume a risk free rate of xyz). 
- Note that the segment below the minimum variance portfolio are dominated. 
- instruction 2

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
stockmu = colMeans(returns)

stockmu = colMeans(returns)
grid = seq(min(stockmu),max(stockmu),length.out=100 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()

for( mutarget in grid ){
  out = try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm = c(vpm,out$pm)
    vpsd = c(vpsd,out$ps)
    mweights = rbind( mweights,out$pw)
  }
}
```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code
# inspect the weights of the minimum variance portfolio
# each row in mweights is a portfolio, 
# select the row corresponding to the minimum variance portfolio
barplot( mweights[ vpsd==min(vpsd),] )
# print them, rounded at 2 decimals, and sorted
sort(round(mweights[ vpsd==min(vpsd),],2),decreasing=TRUE)

# this concenctration is true for almost all portfolios on the frontier
# To see this compute for each portfolio, the maximum weight and plot
# We have 100 portfolios, a row in mweights corresponds to a portfolio
# plot the maximum weights
minvarpm = vpm[vpsd==min(vpsd)]
plot(apply(mweights[ vpm>=minvarpm,],1,"max"),type="l",
     main="Max weight for each of the efficient portfolios", 
     xlab="",ylab="")
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:5cd26622b81e29df3e9a1636d88d48ed0ae3c3c5
## Plotting the efficient frontier  

Write the loop. for(), portfolio.optim()

*** =instructions
- instruction 1
- instruction 2

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}


# assign the stock names to the column names of mweights
colnames(mweights) = colnames(returns)

plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly")
text( stocksd ,  stockmu ,  labels=colnames(returns.estim), cex= 0.7)
lines(vpsd,vpm,col="red")

# Improvements:
# adjust better the limits of the plot
# remove the point on the frontier that are dominated

plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly",
     xlim=c(0.02,0.15), ylim=c(-0.01,0.02))
text( stocksd ,  stockmu ,  labels=colnames(returns.estim), cex= 0.7)

# all portfolios offering less return than the minimum variance portfolio should be excluded
minvarpm = vpm[vpsd==min(vpsd)]
lines(vpsd[vpm>=minvarpm],vpm[vpm>=minvarpm],col="red",lwd=2)
```

*** =solution
```{r}
# solution code
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```


--- type:MultipleChoiceExercise lang:r xp:50 skills:1    key:e647c251a7
## The effect of weight constraints on the frontier

Chapter 2 introduced you to the *univariate* approach of analyzing portfolio performance based on a statistical analysis of the portfolio return series. In this chapter, we consider a *multivariate* analysis and study how the portfolio performance is affected by the interaction between the performance of the individual portfolio positions. 

As a motivating example, let us consider a portfolio invested in two very diverse exchange traded funds (ETFs), namely an ETF tracking the broad US equities market (ETF with symbol SPY) and an ETF track the US bonds market (ETF with symbol AGG). The monthly returns for these ETFs and the 60/40 portfolio that invests every month 60% in the equities ETF and 40% in the bonds ETF are available in the workspace as `returns_bonds`, `returns_equities` and `returns_6040`.   

Verify in the R-console which of the following statements is false. 


*** =instructions
- A portfolio is less volatile than the sum of its component volatilities. This implies that the standard deviation of the 60/40 portfolio is less than `0.6*sd(returns_equities)+0.4*sd(returns_bonds)`. We call this the subadditivity property of the standard deviation.    
- The portfolio mean return equals the sum of the component average returns, that is, `mean(returns_6040)==0.6*mean(returns_equities)+0.4*mean(returns_bonds)`.  
- None of the above statements is correct. 

*** =hint
hint

*** =pre_exercise_code
```{r}
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

grid = seq(min(stockmu),max(stockmu),length.out=100 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()

for( mutarget in grid ){
  out = try(portfolio.optim(x = returns.estim,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm = c(vpm,out$pm)
    vpsd = c(vpsd,out$ps)
    mweights = rbind( mweights,out$pw)
  }
}

# assign the stock names to the column names of mweights
colnames(mweights) = colnames(returns)

 
##################################################################################
# To avoid the concentration, we will impose now a max weight constraint of 10%

 
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm.res = vpsd.res = mweights.res = c()

for( mutarget in grid ){
  out = try(portfolio.optim(x = returns.estim,pm=mutarget,
                  reshigh = rep(0.1,ncol(returns.estim))),silent=TRUE)
  if(class(out)!="try-error"){
    vpm.res = c(vpm.res,out$pm)
    vpsd.res = c(vpsd.res,out$ps)
    mweights.res = rbind( mweights.res,out$pw)
  }
}
# assign the stock names to the column names of mweights
colnames(mweights.res) = colnames(returns)

# 
plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly",
     xlim=c(0.02,0.15), ylim=c(-0.01,0.02))
text( stocksd ,  stockmu ,  labels=colnames(returns.estim), cex= 0.7)
# all portfolios offering less return than the minimum variance portfolio should be excluded
minvarpm.res = vpm.res[vpsd.res==min(vpsd.res)]
lines(vpsd[vpm>=minvarpm],vpm[vpm>=minvarpm],col="red",lwd=2)
lines(vpsd.res[vpm.res>=minvarpm.res],vpm.res[vpm.res>=minvarpm.res],col="blue",lwd=2)
```

*** =sct
```{r}
test_mc(3) # if 3 is the correct option.
```

--- type:VideoExercise lang:r xp:50 skills:1 key:ca405aabc3c21c142aaae409da6302b77b5210ef
## In-sample versus out-of-sample evaluation


*** =video_link
//player.vimeo.com/video/108225030

--- type:NormalExercise lang:r xp:100 skills:1 key:69f72e3a22916ec2ef924a7f212d354f28022366
## Split sample in two: estimation window and evaluation window

Estimation window, out of sample evaluation window. Estimation error

*** =instructions
- instruction 1
- instruction 2

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code

# Splitting return data in sample for estimation and out of sample evaluation 
returns.estim = window(returns, start = "2004-01-01", end = "2011-12-31")
returns.oos = window(returns, start ="2012-01-01", end = "2015-03-31")

```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:6d3bdc717d87317d8c4ccf468836039b35f78440
## Out of sample performance evaluation

Estimation window, out of sample evaluation window. Compare in sample estimated performance with out of sample realized performance.

*** =instructions
- instruction 1
- instruction 2

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

 
--- type:NormalExercise lang:r xp:100 skills:1   key:9d55676210
## It ain't over
 

Importance of optimizing portfolios: Diagram of the different steps: 
1) define objectives and constraint
2) implementation:
* Estimate the parameters needed;
* Find the solver
3) backtest

***
Discuss extensions
 
 
There are many possible objective functions, such as maximizing the expected return, minimizing the variance, maximizing the skewness, minimizing the portfolio's downside risk [slide should show table with 2 columns]

In terms of constraints, there could be the constraint that all weights have to sum to one, that they should be with a box defined by a lower and upper bound, that the risk is below some risk bound, etc. 


The traditional objective of minimizing the portfolio variance under the constraint that the portfolio expected return should be above some target level. This is a quadratic programming problem. At the end of the chapter, I will discuss extensions related to screening stocks using mixed integer linear programming and optimizing more complex objective functions combining different types of objectives and constraints.   

Question about other packages: DEoptim, PortfolioAnalytics. 



*** =instructions
- Load the library PortfolioAnalytics. 
- Explore the functionality of this package by entering the instruction `?PortfolioAnalytics`. 

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec

```

*** =sample_code
```{r}
# sample code
```

*** =solution
```{r}
# solution code
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```



